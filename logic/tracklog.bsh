/********************************** TRACKLOG **********************************/
// GPS refresh rate field ref
final String GPS_REFRESH_RATE_REF = CONTROL_TAB_REF_FULL + "/GPS_Refresh_Rate";
// Tracklog Interval Ref
final String TRACKLOG_DISTANCE_INTERVAL_REF = CONTROL_TAB_REF_FULL + "/Tracklog_Distance_Interval_in_Meters";
final String TRACKLOG_TIME_INTERVAL_REF = CONTROL_TAB_REF_FULL + "/Tracklog_Time_Interval_in_Seconds";

// GPS choice radio button ref
final String GPS_CHOICE_REF = CONTROL_TAB_REF_FULL + "/GPS_choice";

// Tracklog status field ref
final String TRACKLOG_STATUS_REF = CONTROL_TAB_REF_FULL + "/Tracklog_Status";

// Start GPS button ref
final String START_GPS_BUTTON_REF = CONTROL_TAB_REF_FULL + "/Start_GPS";
// Stop GPS button ref
final String STOP_GPS_BUTTON_REF = CONTROL_TAB_REF_FULL + "/Stop_GPS";

// Enable Tracklog button ref
final String ENABLE_TRACKLOG_DISTANCE_BUTTON_REF = CONTROL_TAB_REF_FULL + "/Tracklog_Distance_Button";
final String ENABLE_TRACKLOG_TIME_BUTTON_REF = CONTROL_TAB_REF_FULL + "/Tracklog_Time_Button";
// Turn off Tracklog button ref
final String TURN_OFF_TRACKLOG_BUTTON_REF = CONTROL_TAB_REF_FULL + "/Tracklog_Off";

int curNumTracklogPoints = 0;
int curNumTransectPoints = 0;

// UUID of the current survey unit. Null if not inside a survey unit.
String survey_unit_id = null;

// The possible state for stateAppend.
final String SURVEY_UNIT_STATE_EMPTY = "";
final String SURVEY_UNIT_STATE_START = "Start";
final String SURVEY_UNIT_STATE_END = "End";

String stateAppend = SURVEY_UNIT_STATE_EMPTY;

// The possible state of the tracklog.
final String TRACKLOG_STATE_TIME = "Time";
final String TRACKLOG_STATE_DIST = "Distance";
final String TRACKLOG_STATE_STOP = "Stopped";
final String TRACKLOG_STATE_BAD_GPS_FIX = "Bad GPS Fix";

// Default state of the tracklog is stopped.
String tracklogState = TRACKLOG_STATE_STOP;

String tracklogStatus = "Tracklog is stopped";

boolean transectEnabled = false;

void initAndPersistOverSessions(String ref, String defaultVal) {
  setFieldValue(ref, defaultVal);
  persistOverSessions(ref, defaultVal);
}

boolean isGPSOn() {
  return isInternalGPSOn() || isExternalGPSOn();
}

void setGpsInternalExternal() {
  setFieldValue(GPS_CHOICE_REF, "{Internal}");
}

void updateTracklogStatus() {
  switch(tracklogState) {
    case TRACKLOG_STATE_TIME:
      tracklogStatus = "Tracklog started - Time interval: "+getFieldValue(TRACKLOG_TIME_INTERVAL_REF)+"s";
      break;
    case TRACKLOG_STATE_DIST:
      tracklogStatus = "Tracklog started - Distance interval: "+getFieldValue(TRACKLOG_DISTANCE_INTERVAL_REF)+"m";
      break;
    default:
      tracklogStatus = "Tracklog off";
  }

  if (curNumTracklogPoints > 0) {
      tracklogStatus += "\nNumber Tracklog Points collected: "+curNumTracklogPoints;
  }
  if (curNumTransectPoints > 0) {
      tracklogStatus += "\nNumber current transect Points collected: "+curNumTransectPoints;
  }

  tracklogStatus += "\nCurrent GPS Estimated Accuracy: "+ getGPSEstimatedAccuracy();

  setFieldValue(TRACKLOG_STATUS_REF, tracklogStatus);
  setFieldValue(SURVEY_UNIT_TRACKLOG_STATUS_REF, tracklogStatus);
}

boolean startGPS() {
    Object intext = getFieldValue(GPS_CHOICE_REF);
    if(isNull(intext)) {
        showWarning("Warning", "Please choose whether you would like to connect to internal or external GPS.");
        return false;
    }
    setGPSUpdateInterval(Integer.parseInt(getFieldValue(GPS_REFRESH_RATE_REF)));
    showToast("GPS enabled. GPS refresh rate set to " + getFieldValue(GPS_REFRESH_RATE_REF) + ".");
    if(intext.equals("Internal")) {
        if(isExternalGPSOn()) stopGPS();
        startInternalGPS();
    }
    if(intext.equals("External")) {
        if(isInternalGPSOn()) stopGPS();
        startExternalGPS();
    }
    updateTracklogStatus();
    return true;
}

void stopGPSLogic() {
    if(isInternalGPSOn() || isExternalGPSOn()) {
        showToast("GPS disabled.");
        stopGPS();
    } else {
        showToast("GPS is not turned on.");
    }
}

void startDistanceTracklog() {
    stopTracklog();

    String trackText = getFieldValue(TRACKLOG_DISTANCE_INTERVAL_REF);
    int    trackInt  = Integer.parseInt(trackText);

    if (trackInt <= 0) {
     showToast("Please enter a positive number in the 'Tracklog Distance Interval (m)' field");
    } else if(isGPSOn()) {
        tracklogState = TRACKLOG_STATE_DIST;
        showToast("Tracklog enabled. Tracklog distance interval set to " + trackText + " metres.");
        startTrackingGPS("distance", trackInt, "saveGPSTrack()");
        updateGPSDiagnostics();
        updateTracklogStatus();
    } else {
        showToast("GPS is not turned on.");
    }
}

void startTimeTracklog() {
  stopTracklog();

  String trackText = getFieldValue(TRACKLOG_TIME_INTERVAL_REF);
  int    trackInt  = Integer.parseInt(trackText);

  if (trackInt <= 0) {
      showToast("Please enter a positive number in the 'Tracklog Time Interval (s)' field");
    } else if(isGPSOn()) {
        tracklogState = TRACKLOG_STATE_TIME;
        showToast("Tracklog enabled. Tracklog time interval set to " + trackText + " seconds.");
        startTrackingGPS("time", trackInt, "saveGPSTrack()");
        updateGPSDiagnostics();
        updateTracklogStatus();
    } else {
        showToast("GPS is not turned on.");
    }
}

void stopTracklog() {
    stopTrackingGPS();
    curNumTracklogPoints = 0;
    curNumTransectPoints = 0;
    tracklogState = TRACKLOG_STATE_STOP;
    showToast("Tracklog disabled.");
    updateTracklogStatus();
}

boolean transectEnabled = false;

void saveGPSTrack() {
  if (isInUnitTestTime()) {
      // This function uses the Nutiteq `Point` class, which is difficult to
      // mock.
      return;
    }
  String teamFieldValue = getFieldValue(TEAM_REF);
  String teamQuery = "SELECT vocabname FROM vocabulary WHERE vocabid = {team}";
  teamQuery = dbReplaceFirst(teamQuery, "{team}", teamFieldValue);
    fetchOne("SELECT vocabname FROM vocabulary WHERE vocabid = " + teamFieldValue, new FetchCallback() {
        onFetch(teamQueryResult) {
            position = getGPSPosition();
            if (position == null) {
                tracklogState = TRACKLOG_STATE_BAD_GPS_FIX;
                return;
            }
            positionProj = getGPSPositionProjected();

            curNumTracklogPoints++;

            List attributes = createAttributeList();

            String date = new java.text.SimpleDateFormat("d-MMM-yy HH:MM:ss z").format(new Date());
            String curTracklogTeam = teamQueryResult.get(0);

            attributes.add(createEntityAttribute("Longitude", null, null, "" + position.getLongitude(), null));
            attributes.add(createEntityAttribute("Latitude", null, null, "" + position.getLatitude(), null ));
            attributes.add(createEntityAttribute("Easting", null, null, "" + positionProj.getLongitude(), null));
            attributes.add(createEntityAttribute("Northing", null, null, "" + positionProj.getLatitude(), null ));
            attributes.add(createEntityAttribute("Heading", null, null, "" + getGPSHeading(), null));
            attributes.add(createEntityAttribute("Accuracy", null, null, "" + getGPSEstimatedAccuracy(), null));
            attributes.add(createEntityAttribute("Timestamp", null, null, "" + date, null));
            attributes.add(createEntityAttribute("TracklogTeam", null, null, curTracklogTeam, null));

            Point p = new Point(new MapPos(positionProj.getLongitude(), positionProj.getLatitude()), null, null, null);
            ArrayList l = new ArrayList();
            l.add(p);

            String surveyUnitIdRef = SURVEY_UNIT_TAB_REF_FULL + "/Survey_Unit_ID";
            Log.d("surveyUnit", "Class: " + getFieldValue(surveyUnitIdRef).getClass() + " Value:  " + getFieldValue(surveyUnitIdRef) );
            String surveyUnitTotalTransectWidthRef = SURVEY_UNIT_TAB_REF_FULL + "/Total_Transect_Width";
            saveArchEnt(null, "Tracklog", l, attributes, new SaveCallback() {
                onSave(uuid, newRecord) {
                  updateTracklogStatus();


                    if (transectEnabled) {
                        curNumTransectPoints++;
                        // attributes.add(createEntityAttribute("SUID", getFieldValue(surveyUnitIdRef), null, null, null));
                        // attributes.add(createEntityAttribute("Width", getFieldValue(surveyUnitTotalTransectWidthRef), null, null, null));
                        if (!stateAppend.equals(SURVEY_UNIT_STATE_EMPTY)) {
                            // attributes.add(createEntityAttribute("State", stateAppend, null, null, null));
                            if(stateAppend.equals("End")) {
                                transectEnabled=false;
                                Log.d("FAIMS", "stateAppend end -> transectEnabled is now" + transectEnabled);
                            }
                            stateAppend = SURVEY_UNIT_STATE_EMPTY;
                            Log.d("FAIMS", "stateAppend: " + stateAppend);
                        }
                        /*
                        saveArchEnt(null, "Transect", l, attributes, new SaveCallback() {
                            onSave(uuid, newRecord) {
                                transect_id = uuid;
                                if(transectEnabled) {
                                    saveEntitiesToRel("TransectSUI", transect_id, survey_unit_id);
                                } else {
                                    saveEntitiesToRel("TransectSUI", transect_id, survey_unit_id, new Callable() {
                                        call() {
                                            drawSurveyUnit();
                                        }
                                    });
                                }
                                updateTracklogStatus();
                            }
                        });
                        */
                    }

                }

            });

        }
    });
}

drawSurveyUnit() {
    fetchOne("update archentity set geospatialcolumn = (select casttogeometrycollection(geom) " +
            "from ( " +
            "select makeline(transform(geospatialcolumn, 4326)) as geom " +
              "from (select * from latestnondeletedarchent join aenttype using (aenttypeid) join latestnondeletedaentreln using (uuid) where aenttypename = 'Transect' order by uuid) Transect  " +
              "join (select uuid, relationshipid from latestnondeletedarchent join aenttype using (aenttypeid) join latestnondeletedaentreln using (uuid)  where aenttypename = 'Survey Unit' ) survey_unit using (relationshipid)  " +
              "join (select uuid, measure from latestnondeletedaentvalue join attributekey using (attributeid) where attributename = 'Total Transect Width (m)' )   " +
             "where survey_unit.uuid = " + survey_unit_id + "  " +
             "group by survey_unit.uuid) " +
             ") where uuid = " + survey_unit_id + " and aenttimestamp = (select aenttimestamp from latestnondeletedarchent where uuid = " + survey_unit_id + ");", null);
}


void initAndPersistTracklogIntervals() {
  initAndPersistOverSessions(TRACKLOG_DISTANCE_INTERVAL_REF, "100");
  initAndPersistOverSessions(TRACKLOG_TIME_INTERVAL_REF, "30");
}

void initAndPersistGPSRefreshRate() {
  initAndPersistOverSessions(GPS_REFRESH_RATE_REF,   "60");
}

void setSurveyUnitState(String state) {
  stateAppend = state;
}

void enableTransect() {
  transectEnabled = true;
}

void disableTransect() {
  transectEnabled = false;
}

void setCurrentNumOfTransectPoint(int n) {
  curNumTransectPoints = n;
}

void resetCurrentNumOfTransectPoint() {
  setCurrentNumOfTransectPoint(0);
}

void setCurrentSurveyUnitToNull() {
  survey_unit_id = null;
}

// If GPS position is null, return false, else return true.
boolean GPSPositionNotNull() {
  if(getGPSPosition() == null) {
    return false;
  }
  return true;
}

setGpsInternalExternal();

addOnEvent(CONTROL_TAB_REF_FULL, "show", "setGpsInternalExternal()");

addOnEvent(START_GPS_BUTTON_REF, "click", "startGPS();");
addOnEvent(STOP_GPS_BUTTON_REF, "click", "stopGPSLogic();");

addOnEvent(ENABLE_TRACKLOG_DISTANCE_BUTTON_REF, "click", "startDistanceTracklog()");
addOnEvent(ENABLE_TRACKLOG_TIME_BUTTON_REF, "click", "startTimeTracklog()");
addOnEvent(TURN_OFF_TRACKLOG_BUTTON_REF, "click", "stopTracklog()");


initAndPersistGPSRefreshRate();
initAndPersistTracklogIntervals();
